

//------------ BEGIN ./main.mtl ------------

proto main 0;;
var NOMINAL;;



//------------ BEGIN ./lib/std/utils.mtl ------------
// --------------- UTIL debut
//fun strcmp a b = vstrcmp a 0 b 0 nil;;
fun strstr s p i=strfind s i p 0 nil;;
fun itoanil l=if l==nil then '0'::nil else l;;
fun listlen l=if l==nil then 0 else 1+listlen tl l;;
fun listrem l x=if l!=nil then if x==hd l then tl l else (hd l)::listrem tl l x;;
fun slistlen l=	if l==nil then 0 else (strlen hd l)+slistlen tl l;;
fun listnth l i=if !i then hd l else if i>0 then listnth tl l i-1;;

fun listtostr l=
	let strnew listlen l -> s in
	let 0->i in
	(
		for p=l;p!=nil;tl p do
		(
			strset s i hd p;
			set i=i+1
		);
	s
	);;

fun atoibin2 val=itobin2 atoi val;;

fun countpattern s p i=
	let strstr s p i -> j in
	if j==nil then 0
	else 1+countpattern s p j+strlen p;;

fun strreplace2 sn s p v i id=
	if i<strlen s then
	let strstr s p i -> j in
	let if j==nil then strlen s else j -> k in
	(
		strcpy sn id s i k-i;
		if j!=nil then strcpy sn id+k-i v 0 nil;
		strreplace2 sn s p v k+strlen p id+k-i+strlen v
	);;
	
fun strreplace s p v=
	let countpattern s p 0 -> i in
	if !i then s
	else let strnew (strlen s) + ((strlen v)-(strlen p))*i -> sn in
	(
		strreplace2 sn s p v 0 0;
		sn
	);;


fun rev p q=if p==nil then q else rev tl p (hd p)::q;;

fun remfromlist l t= if l!=nil then if t==hd l then tl l else (hd l)::remfromlist tl l t;;

fun insert x l f=
	if l==nil then x::nil
	else let call f [x hd l] -> r in
	if r>0 then (hd l)::insert x tl l f
	else if r<0 then x::l
	else insert x tl l f;;

fun sort l f= if l!=nil then insert hd l sort tl l f f;;

fun select l a f= if l!=nil then let hd l-> x in if call f [x a] then x::select tl l a f else select tl l a f;;

fun conc p q=if p==nil then q else (hd p)::conc tl p q;;

fun _useparamip s i val j=
	if i<4 then
	let strstr val "." j -> k in
	(
		strset s i atoi strsub val j if k==nil then nil else k-j;
		_useparamip s i+1 val if k==nil then strlen val else k+1
	);;

fun useparamip val=
	let strnew 4 -> ip in
	(
		_useparamip ip 0 val 0;
		ip
	);;

fun webip ip=
	strcatlist (itoa strget ip 0)::"."::(itoa strget ip 1)::"."::(itoa strget ip 2)::"."::(itoa strget ip 3)::nil;;

fun _webmac key i=
	if i<strlen key then (ctoh strget key i)::if i+1<strlen key then ":"::_webmac key i+1 else _webmac key i+1;;

fun webmac key=strcatlist _webmac key 0;;

// proto setleds 1;;

// ---------------- UTIL fin

//------------ END ./lib/std/utils.mtl ------------


//------------ BEGIN ./lib/std/debug.mtl ------------


fun MACecho src i0 ln=
	for i=0;i<6 do (Secho ctoh strget src i0+i; Secho ".");	if ln then Secholn "";
	src;;

fun SEQecho src i0 ln=
	for i=0;i<4 do (Secho ctoh strget src i0+i; Secho ".");	if ln then Secholn "";
	src;;

fun IPecho src i0 ln=
	for i=0;i<4 do (Iecho strget src i0+i; Secho ".");if ln then Secholn "";
	src;;

fun itoh4 i = strcatlist (ctoh i>>24)::(ctoh i>>16)::(ctoh i>>8)::(ctoh i)::nil;;

fun dump s=
	for i0=0;i0<strlen s;i0+16 do
	(
		Secho itoh4 i0;
		Secho " ";
		for i=0;i<16 do let strget s i0+i -> c in
		(
			Secho if c==nil then "  " else ctoh c;
			Secho " "
		);
		Secho " ";
		for i=0;i<16 do let strget s i0+i -> c in
		(
			Secho if c==nil then "  " else if c<32 then "." else ctoa c
		);
		Secholn ""
	);

	s;;

fun dumpscan l0=
	Secholn "## DUMPSCAN >>>>";
	for l=l0;l!=nil;tl l do
	let hd l->[ssid mac bssid rssi channel rateset encryption] in
	(
		Secho "## SCAN "; Secholn ssid;
		Secho "mac:"; MACecho mac 0 1;
		Secho "bssid:"; MACecho bssid 0 1;
		Secho "rssi:"; Iecholn rssi;
		Secho "channel:"; Iecholn channel;
		Secho "rateset:"; Iecholn rateset;
		Secho "encryption:"; Iecholn encryption
	);
	l0;;

//------------ END ./lib/std/debug.mtl ------------


//------------ BEGIN ./lib/const/config.mtl ------------

ifdef NOMINAL
{
var AUDIOLIB;;
var EARSLIB;;
var INFOLIB;;
var RECLIB;;
}

ifdef SIMU
{
var HARDWARE=4;;
var DNSLOCAL=999;;
}
else
{
var HARDWARE=4;;
var DNSLOCAL=1597;;
}

// proto buttoncheckevent 0;;



type Wifi=initW | gomasterW | masterW | gostationW _ | dhcpW _| stationW | reconnectW;;
var wifi;;

var netip="\0\0\0\0";;
var netmask="\255\255\255\0";;
var netgateway="\0\0\0\0";;
var netdns="\0\0\0\0";;

var mymac;;

var macbroadcast="\$ff\$ff\$ff\$ff\$ff\$ff";;
var ipbroadcast="\$ff\$ff\$ff\$ff";;

var master=0;;

var netip_empty="\0\0\0\0";;

var netip_master="\192\168\2\1";;
var netmask_master="\255\255\255\0";;
var netgateway_master="\192\168\0\1";;

var wifiscans;;

var IEEE80211_CRYPT_NONE=0;;
var IEEE80211_CRYPT_WEP64=1;;
var IEEE80211_CRYPT_WEP128=2;;
var IEEE80211_CRYPT_WPA=3;;
var IEEE80211_CRYPT_WPA_UNSUPPORTED=4;;

var IEEE80211_AUTH_OPEN=0;;
var IEEE80211_AUTH_SHARED=1;;

var FIRMWARE=0x01010f;;


var RT2501_S_BROKEN=0;;
var RT2501_S_IDLE=1;;
var RT2501_S_SCAN=2;;
var RT2501_S_CONNECTING=3;;
var RT2501_S_CONNECTED=4;;
var RT2501_S_MASTER=5;;

var IEEE80211_M_MANAGED=0;;
var IEEE80211_M_MASTER=1;;


// ------------- Config debut
var CONF_SERVERURL=0;;		//41
var CONF_NETDHCP=41;;		//1
var CONF_NETIP=42;;			//4
var CONF_NETMASK=46;;		//4
var CONF_NETGATEWAY=50;;	//4
var CONF_NETDNS=54;;		//4
var CONF_WIFISSID=58;;		//32
var CONF_WIFIAUTH=90;;		//1
var CONF_WIFICRYPT=91;;		//1
var CONF_WIFIKEY0=92;;		//64
var CONF_PROXYENABLE=156;;	//1
var CONF_PROXYIP=157;;		//4
var CONF_PROXYPORT=161;;	//2
var CONF_LOGIN=163;;		//6
var CONF_PWD=169;;			//6
var CONF_WIFIPMK=175;;		//32
var CONF_MAGIC=207;;		//1
var CONF_LENGTH=208;;

var conf;;

/*
var conf0=
"r.nabaztag.com/vl\0-----------------------\
\1\0\0\0\0\255\255\255\0\0\0\0\0\0\0\0\0\
\0-------------------------------\
\0\0abcde\0----------------------------------------------------------\
\0\0\0\0\0\0\0\
\0\0\0\0\0\0\
\0\0\0\0\0\0\
--------------------------------\
\$48";;
*/

fun confSave=
	Secholn "## save configuration";
	dump conf;
	save conf 0 "conf.bin" 0 CONF_LENGTH;;

fun confInit=
	set conf=strnew CONF_LENGTH;
	load conf 0 "conf.bin" 0 CONF_LENGTH;
/*	if (strget conf CONF_MAGIC)!=0x48 then
	(
		set conf=strnew CONF_LENGTH;
		strcpy conf 0 conf0 0 nil;
		confSave;
		set conf=strnew CONF_LENGTH;
		load conf 0 "conf.bin" 0 CONF_LENGTH
	);
*/	dump conf;;

fun confGet i len= strsub conf i len;;

fun confGetbin i len= strsub conf i len;;

fun confGetstr i len=
	let strstr conf "\0" i -> j in
	strsub conf i (if j==nil then len else min len j-i);;

fun confSet i val len=
	strcpy conf i val 0 len;;

fun confSetbin i val len=strcpy conf i val 0 len;;

fun confSetstr i val len=
	let min strlen val len-1 -> len in
	(
		strcpy conf i val 0 len;
		strset conf i+len 0
	);;

fun webport s= ((strget s 0)<<8)+strget s 1;;

fun confGetWifissid=confGetstr CONF_WIFISSID 32;;
fun confGetWificrypt=strget confGet CONF_WIFICRYPT 1 0;;
fun confGetWifikey0=confGetstr CONF_WIFIKEY0 64;;
fun confGetWifiauth=strget confGet CONF_WIFIAUTH 1 0;;
fun confGetWifipmk=confGetbin CONF_WIFIPMK 32;;

fun confGetDhcp=strget confGet CONF_NETDHCP 1 0;;
fun confGetNetip=confGet CONF_NETIP 4;;
fun confGetNetmask=confGet CONF_NETMASK 4;;
fun confGetNetgateway=confGet CONF_NETGATEWAY 4;;
fun confGetNetdns=confGet CONF_NETDNS 4;;

fun confGetServerUrl=confGetstr CONF_SERVERURL 40;;
fun confGetLogin=confGet CONF_LOGIN 6;;
fun confGetPwd=confGet CONF_PWD 6;;

fun confGetProxy=strget confGet CONF_PROXYENABLE 1 0;;
fun confGetProxyip=confGet CONF_PROXYIP 4;;
fun confGetProxyport=webport confGet CONF_PROXYPORT 2;;

// ------------- Config fin



//------------ END ./lib/const/config.mtl ------------




//------------ BEGIN ./lib/net/arp.mtl ------------
// ------------- ARP debut
var ARPREQ=1;;
var ARPANS=2;;

var larp;;
var larpreq;;


fun mkarp op ipsrc macdst ipdst=
	strcatlist
	"\$aa\$aa\$03\$00\$00\$00\$08\$06\$00\$01\$08\$00\$06\$04\$00"::(ctoa op)::
	mymac::
	netip::
	macdst::
	ipdst
	::nil;;

fun sendarp ip=
	netSend (mkarp ARPREQ netip macbroadcast ip) 0 nil macbroadcast 0 1;;


fun filterarpip l src =
	if l!=nil then let hd l->[ip _ _] in if !vstrcmp src 8+14 ip 0 4  then filterarpip tl l src
	else (hd l)::filterarpip tl l src;;

fun checkarp l src=
	if l!=nil then let hd l->[ip _ cb] in 
	(
		if !vstrcmp src 8+14 ip 0 4 then
		let strsub src 8+8 6 -> mac in
		(
			Secho "found MAC target : "; MACecho mac 0 1;
			set larp=[ip mac]::larp;
			call cb [mac]
		);
		checkarp tl l src
	);;

fun cbnetarp src mac=
	Secho "<a";
	let strget src 8+7-> op in
	if op==1 then // req
	(
//		Secho "ask ";MACecho src 16+10 1; IPecho src 16+16 1;
		if !vstrcmp src 32 netip 0 4 then
			netSend (mkarp ARPANS netip strsub src 16 6 strsub src 22 4) 0 nil mac 0 1;
		nil
	)
	else if op==2 then
		let larpreq->l in
		(
			set larpreq=filterarpip larpreq src;
			checkarp l src
		);;

fun subnet_ ip i=
	if i<0 then 1
	else if ((strget ip i)^(strget netip i))&(strget netmask i) then 0
	else subnet_ ip i-1;;

fun subnet ip=
	Secho "test subnet "; IPecho ip 0 1;
	Iecholn subnet_ ip 3;;
	
	
fun arpreq ip cb=
	let IPecho (if subnet ip then ip else netgateway) 0 1 -> ip in
	let listswitchstr larp ip -> mac in
	if mac!=nil then call cb [mac]
	else
	(
		sendarp ip;
		set larpreq=[ip time cb]::larpreq;	// ### attention � la taille de la liste
		0
	);;

fun filterarp l dt =
	if l!=nil then let hd l->[ip t _] in if (time-t)>dt then filterarp tl l dt
	else
	(
		sendarp ip;
		(hd l)::filterarp tl l dt
	);;

fun arptime =
	set larpreq=filterarp larpreq 10;;

fun resetarp=
	set larp=nil;
	set larpreq=nil;
	0;;

// ------------- ARP fin

//------------ END ./lib/net/arp.mtl ------------


//------------ BEGIN ./lib/net/ip.mtl ------------
// ------------- IP debut
fun strputchk s i w=
	strset s i ~(w>>8);
	strset s i+1 ~w;
	0;;

// ------------- IP fin

//------------ END ./lib/net/ip.mtl ------------


//------------ BEGIN ./lib/net/tcp.mtl ------------
// ------------- TCP debut
var TFIN=0x01;;
var TSYN=0x02;;
var TRST=0x04;;
var TPUSH=0x08;;
var TACK=0x10;;
var TURGE=0x20;;

var STOFF=-1;;
var STSYN=0;;
var STEST=1;;
var STLISTEN=2;;
var STFIN=3;;

var CLIENT_SEQ_START="\0\0\1\0";;
var CLIENT_SEQ_NULL="\0\0\0\0";;

var TCPWRITE=0;;
var TCPREAD=1;;
var TCPCLOSE=-1;;
var TCPSTART=2;;

var TCPMAX=1024;;

type Tcp=[stateT locT dstT locpT dstpT seqT ackT cbT macT lastsentT retryT locksendT enableT];;

fun mktcp_ ipsrc ipdst portsrc portdst seq ack flag content=
	let strcatlist 
	"\$aa\$aa\$03\$00\$00\$00\$08\$00\$45\$00\$00\$00\$00\$00\$00\$00\100\6\0\0"::
	ipsrc::
	ipdst::
	"\0\0\0\0"::
	seq::
	ack::
	"\0\0\$ff\$ff\0\0\0\0"::
	if flag&TSYN then "\2\4\5\$b4"::content::nil	// 5.b4 final : taille MSS
	else content::nil
	-> tcp in
	let strlen tcp ->len in
	(
		strputword tcp 8+2 len-8;
		strputword tcp 8+20 portsrc;
		strputword tcp 8+22 portdst;

		strset tcp 8+32 4*if flag&TSYN then 24 else 20;
		strset tcp 8+33 flag;

		strputchk tcp 8+10 netChk tcp 8 20 0;

		let strnew 2 -> s in
		(
			strputword s 0 len-28;
			strputchk tcp 8+36
			 netChk tcp 8+20 (len-28) netChk s 0 2 netChk "\0\6" 0 nil netChk tcp 8+12 8 0
		);
		tcp
	);;

fun mktcp t flag content=
//	Secholn "mktcp "; Secho "seq "; SEQecho t.seqT 0 1; Secho "ack "; SEQecho t.ackT 0 1;
	mktcp_ t.locT t.dstT t.locpT t.dstpT t.seqT t.ackT flag content;;

fun resendtcp t=
	netSend t.lastsentT 0 nil (MACecho t.macT 0 1) 0 1;
	0;;

fun headerlen src=((strget src 8+32)>>4)<<2;;

fun datalength src=(strgetword src 10)-20-headerlen src;;

fun sendtcp t trame=
//	Secholn "tcpSend"; dump trame; 
	netSend trame 0 nil (/*MACecho*/ t.macT /*0 1*/) 0 1;
	let strget trame 8+33 -> flag in
	set t.seqT=netSeqAdd t.seqT (datalength trame)+(if flag&(TSYN|TFIN) then 1 else 0);
	0;;

fun sendtcpforretry t trame=
	set t.lastsentT=trame;
	set t.retryT=nil;
	sendtcp t trame;;


fun tcpSend2 mac tcp trame=
	set tcp.macT=mac;
	sendtcpforretry/*sendtcp*/ tcp trame;;

var ltcp;;


fun remtcp t=set t.stateT=STOFF; set ltcp=remfromlist ltcp t;;

var counttcp;;

fun opentcp local localp dst dstp cb=
	let if localp==nil then 1024+set counttcp=((if counttcp==nil then time_ms else counttcp)+1)&16383 else localp -> localp in
	let [stateT:STSYN locT:local dstT:dst locpT:localp dstpT:dstp seqT:CLIENT_SEQ_START ackT:CLIENT_SEQ_NULL cbT:cb enableT:1] -> tcp in
	let mktcp tcp TSYN nil -> trame in
	let dst -> ip in	//	ajouter le test de passerelle
	(
		set ltcp=tcp::ltcp;
		arpreq ip fixarg2 fixarg3 #tcpSend2 trame tcp;
		tcp
	);;

fun listentcp localp cb=
	let [stateT:STLISTEN locpT:localp cbT:cb enableT:1] -> tcp in
	(
		set ltcp=tcp::ltcp
	);;
	
fun findtcp l localp dstp src=
	if l!=nil then let hd l-> t in
	if t.locpT==localp && t.dstpT==dstp && (!vstrcmp src 8+16 t.locT 0 4)&& (!vstrcmp src 8+12 t.dstT 0 4)
	then t
	else if t.stateT==STLISTEN && t.locpT==localp then t
	else findtcp tl l localp dstp src;;

fun sendclose t=
	Secholn "## sendclose";
	sendtcp t mktcp t TFIN+TACK nil;
	set t.stateT=STFIN;
	0;; 

fun cbnettcp src mac=
	Secho "t";
	let /*Iecholn*/ strgetword src 8+20+2 -> locp in
	let /*Iecholn*/ strgetword src 8+20+0 -> dstp in
	let findtcp ltcp locp dstp src -> t in
	if t!=nil && t.enableT then let t.stateT -> st in
		let /*Iecholn*/ strget src 8+33 -> flag in
		let /*SEQecho*/ (strsub src 8+24 4) /*0 1*/-> rseq in
		let /*SEQecho*/ (strsub src 8+28 4) /*0 1*/-> rack in
		if st==STSYN then
		(
			Secholn "stsyn";
			if (flag==TSYN+TACK) && !vstrcmp (SEQecho(t.seqT)0 1) 0 rack 0 4 then
			(
				set t.ackT=SEQecho (netSeqAdd rseq 1) 0 1;
				sendtcp t mktcp t TACK nil;
				set t.stateT=STEST;
				set t.lastsentT=nil;
//				Secholn "call TCPWRITE";
				call t.cbT [t TCPWRITE nil]
			)
			else
			(
//				Secholn "TSRT+TACK";
				sendtcp t mktcp t TRST+TACK nil;
				remtcp t;
				nil
			)
		)
		else if st==STEST then
			if !vstrcmp t.ackT 0 rseq 0 4 then
			let strgetword src 10 -> iplen in
			let ((strget src 8+32)>>4)<<2 -> tcplen in
			let datalength src -> datalen in
			(
				if datalen then
				(
	//				dump src;
	//				Iecholn iplen;
	//				Iecholn tcplen;
//					Secho "update ackT : add ";
					set t.ackT=netSeqAdd t.ackT datalen
				);
				if flag&TFIN then
				(
					set t.ackT=netSeqAdd t.ackT 1;
					nil
				)
				else if !vstrcmp t.seqT 0 rack 0 4 then
				(
//					Secholn "acquittement de l'envoi";
					set t.lastsentT=nil;	// acquittement de l'envoi
					if t.locksendT==1 then
					(
						set t.locksendT=0;
						call t.cbT [t TCPWRITE nil]
					)
					else if t.locksendT==2 then
					(
						sendclose t;
						nil
					)
				)
				else (Secholn "##bad ack"; SEQecho t.seqT 0 1;SEQecho rack 0 1; nil);
				if datalen then
					let 8+20+headerlen src -> start in
					let strsub src start datalen -> data in
					call t.cbT [t TCPREAD data];
				if datalen || flag&TFIN then sendtcp t mktcp t TACK nil;
				if flag&TFIN then
				(
					sendtcp t mktcp t TFIN+TACK nil;
					remtcp t;
					call t.cbT [t TCPCLOSE nil]
				)
			)
			else (/*SEQecho(t.ackT)0 1; SEQecho rseq 0 1;*/Secho "##bs/";sendtcp t mktcp t TACK nil; nil)
		else if st==STFIN then
			(
				Secholn "STFIN";
				set t.ackT=SEQecho (netSeqAdd rseq 1) 0 1;
				sendtcp t mktcp t TACK nil;
				remtcp t;
				nil
			)
		else if st==STLISTEN then
			if flag&TSYN then
			(
				let [stateT:STEST locT:(strsub src 8+16 4) dstT:(strsub src 8+12 4) locpT:locp dstpT:dstp
				seqT:CLIENT_SEQ_START ackT:(netSeqAdd rseq 1) cbT:t.cbT macT:mac  enableT:1] -> tcp in
				(
					set ltcp=tcp::ltcp;
					sendtcpforretry tcp mktcp tcp TACK+TSYN nil;
					call tcp.cbT [tcp TCPSTART nil]
				)
			)
	;;


fun writetcp t msg i=
	if t.stateT!=STEST then nil
	else if t.lastsentT!=nil then
	(
//		Secholn "locksend";
		set t.locksendT=1;
		i
	)
	else let strsub msg i TCPMAX -> content in
	let mktcp t TACK content -> trame in
	(
		sendtcpforretry t trame;
		let i+strlen content -> ni in
		(
			if ni!=strlen msg then set t.locksendT=1;
			ni
		)
	);;


fun closetcp t=
	if t.stateT!=STEST then 0
	else if t.lastsentT!=nil then
	(
		set t.locksendT=2;
		0
	)
	else sendclose t;
	0;;

fun tcpcb t cb= set t.cbT=cb;;

fun enabletcp t v= set t.enableT=v;;

fun tcptime =
	for l=ltcp;l!=nil;tl l do let hd l-> t in
	if t.lastsentT!=nil then
	(
		if t.retryT!=nil then
		(
			set t.retryT=1+t.retryT;
			if t.retryT>10 then
			(
				remtcp t;
				call t.cbT [t TCPCLOSE nil];
				nil
			)
			else resendtcp t
		)
		else set t.retryT=0
	);
	0;;

fun resettcp=
	set ltcp=nil;
	0;;

// -------------- TDP fin

//------------ END ./lib/net/tcp.mtl ------------


//------------ BEGIN ./lib/net/udp.mtl ------------
// ------------- UDP debut
fun mkudp ipsrc ipdst portsrc portdst content=
	let strcatlist 
	"\$aa\$aa\$03\$00\$00\$00\$08\$00\$45\$00\$00\$00\$00\$00\$00\$00\100\17\0\0"::
	ipsrc::
	ipdst::
	"\0\0\0\0\0\0\0\0"::
	content::
	nil -> udp in
	(
		strputword udp 8+2 28+strlen content;
		strputword udp 8+20 portsrc;
		strputword udp 8+22 portdst;
		strputword udp 8+24 8+strlen content;
		strputchk udp 8+10 netChk udp 8 20 0;
		strputchk udp 8+26 netChk udp 8+20 (8+strlen content) netChk udp 8+24 2 netChk "\0\17" 0 nil netChk udp 8+12 8 0;
		udp
	);;

fun udpSend2 mac udp=
	Secho ">u";
//	dump udp;
	netSend udp 0 nil (MACecho mac 0 1) 0 1;;

fun udpsend local localp dst dstp content mac=
	let mkudp local dst localp dstp content -> udp in
	if mac!=nil then udpSend2 mac udp
	else let dst -> ip in	//	ajouter le test de passerelle
	arpreq ip fixarg2 #udpSend2 udp;;

var ludp;;

fun remudp l port=
	if l!=nil then let hd l ->[p _] in if p==port then remudp tl l port else (hd l)::remudp tl l port;;

fun regudp port cb=
	set ludp=[port cb]::remudp ludp port;;

fun unregudp port=
	set ludp=remudp ludp port;;

fun resetudp= set ludp=nil;;

fun cbnetudp src mac=
	Secho "<u";
	let Iecholn strgetword src 8+20+2 -> locp in
	let listswitch ludp locp -> cb in
	call cb [strsub src 8+20+8 nil mac strsub src 20 4];;


// -------------- UDP fin

//------------ END ./lib/net/udp.mtl ------------


//------------ BEGIN ./lib/net/dhcp.mtl ------------
// --------------- DHCP debut

var DHCP_DISCOVER=1;;
var DHCP_OFFER=2;;
var DHCP_REQUEST=3;;
var DHCP_DECLINE=4;;
var DHCP_ACK=5;;

fun mkdhcp op netip hostip newip =
	let 236+16+14->n in
	let strnew n -> b in
	(
		for i=0;i<n do strset b  i 0;
		strcpy b 0 "\1\1\6" 0 3;
		strcpy b 12 netip 0 4;
		strcpy b 12+16 mymac 0 6;
		strcpy b 236 "\99\130\83\99\53\1" 0 6;
		strset b 236+6 op;
		strcpy b 236+7 "\61\7\1" 0 3;
		strcpy b 236+10 mymac 0 6;
		strcpy b 236+16 "\12\7Pabcdef\55\3\1\3\6" 0 14;
		if op==DHCP_REQUEST then strcatlist b::"\54\4"::hostip::"\50\4"::newip::"\255"::nil
		else strcat b "\255"
	);;

fun mkdhcpans op tid newip dmac=
	let 236+7->n in
	let strnew n -> b in
	(
		for i=0;i<n do strset b  i 0;
		strcpy b 0 "\2\1\6" 0 3;
		strcpy b 4 tid 0 4;
		strcpy b 16 newip 0 4;
		strcpy b 12+16 dmac 0 6;
		strcpy b 236 "\99\130\83\99\53\1" 0 6;
		strset b 236+6 op;
		strcatlist b::"\54\4"::newip::"\51\4\0\1\$51\$80\1\4"::netmask::"\3\4"::netip::"\6\4"::netip::"\15\4home\255"::nil
	);;

fun extractdhcp src i type lease submask dns gateway mac=
	if i<strlen src then
	let strget src i -> c in
	if c==255 then [type lease submask dns gateway mac]
	else let strget src i+1 -> len in
	let i+2->i in
	if c==53 then extractdhcp src i+len (strget src i) lease submask dns gateway mac
	else if c==51 then extractdhcp src i+len type (strgetword src i) submask dns gateway mac
	else if c==1 then extractdhcp src i+len type lease (strsub src i 4) dns gateway mac
	else if c==6 then extractdhcp src i+len type lease submask (strsub src i 4) gateway mac
	else if c==3 then extractdhcp src i+len type lease submask dns (strsub src i 4) mac
	else if c==61 then extractdhcp src i+len type lease submask dns gateway (strsub src i+1 6)
	else extractdhcp src i+len type lease submask dns gateway mac;;

fun mkdhcpip mac=
	let strnew 4 -> s in
	(
		strcpy s 0 netip 0 4;
		strset s 3 ((strget mac 5)&0x7f)+100;
		s
	);;

fun cbnetdhcp src macfrom hostip=
	Secholn "<dhcp"; MACecho macfrom 0 1;
	let strget src 0 -> x in
	let MACecho (strsub src 28 6)0 1 -> mac in
	if x==2 && !strcmp mac mymac then
	(
		let IPecho (strsub src 16 4) 0 1-> newip in
		let extractdhcp src 240 0 nil nil nil nil nil->[type lease submask dns gateway _] in
		if type==DHCP_OFFER then
		(
			Secholn ">>>>>>>>>>>>>>>OFFER";
			udpsend netip 68 ipbroadcast 67 (mkdhcp DHCP_REQUEST netip hostip newip) macbroadcast;
			nil
		)
		else if type==DHCP_ACK then
		(
			Secholn ">>>>>>>>>>>>>>>ACK";
			Secho "server    ";IPecho hostip 0 1;
			Secho "ip        ";IPecho set netip=newip 0 1;
			Secho "type      ";Iecholn type;
			Secho "leasetime ";Iecholn lease;
			Secho "submask   ";IPecho set netmask=submask 0 1;
			Secho "dns       ";IPecho set netdns=dns 0 1;
			Secho "gateway   ";IPecho set netgateway=gateway 0 1;
			nil
		)
	);;

fun cbnetdhcp67 src macfrom hostip=
	Secholn "<dhcp"; MACecho macfrom 0 1;
	let strget src 0 -> x in
	let MACecho (strsub src 28 6)0 1 -> mac in
	if x==1 /*&& !strcmp mac mymac*/ then
	(
		let extractdhcp src 240 0 nil nil nil nil nil ->[type _ _ _ _ dmac] in
		let strsub src 4 4 -> tid in
		let mkdhcpip macfrom -> newip in
		if type==DHCP_DISCOVER then
		(
			Secholn ">>>>>>>>>>>>>>>DISCOVER";
//			dump src;
			udpsend netip 67 ipbroadcast 68 (mkdhcpans DHCP_OFFER tid newip dmac) macbroadcast;
			nil
		)
		else if type==DHCP_REQUEST then
		(
			Secholn ">>>>>>>>>>>>>>>REQUEST";
//			dump src;
			udpsend netip 67 ipbroadcast 68 (mkdhcpans DHCP_ACK tid newip dmac) macbroadcast;
			nil
		)

	);;

fun startdhcp=
	udpsend netip 68 ipbroadcast 67 (mkdhcp DHCP_DISCOVER "\0\0\0\0" nil nil) macbroadcast;
	regudp 68 #cbnetdhcp;
	0;;

fun startdhcpserver=
	regudp 67 #cbnetdhcp67;
	0;;

// --------------- DHCP fin

//------------ END ./lib/net/dhcp.mtl ------------


//------------ BEGIN ./lib/net/net.mtl ------------
// --------------- net HOOK debut

fun net src mac=
	Secho "n ";//MACecho mac 0 1;
//	dump src;
	let strget src 7 -> p in
	(
		if p==6 then cbnetarp src mac // ARP
		else if p==0 then
			let strget src 17 -> ip in
			if ip==6 then cbnettcp src mac
			else if ip==17 then cbnetudp src mac;
		0
	);
	// droso comment
	// buttoncheckevent;
	0;;

fun netstart=
	netCb #net;
	resetarp;
	resettcp;
	resetudp;
	0;;

fun nettime=
	arptime;
	tcptime;
	0;;

// --------------- net HOOK fin

//------------ END ./lib/net/net.mtl ------------


//------------ BEGIN ./lib/net/dns.mtl ------------
// --------------- DNS debut
fun parsequ s i= let strfind s i "\0" 0 nil -> j in	j+5;;

fun parsequs s i n=	if n<=0 then i else parsequs s parsequ s i n-1;;

fun skipname s i=
	let strgetword s i -> x in
	if (x&0xc000)==0xc000 then i+2
	else (strfind s i "\0" 0 nil)+1;;

fun parseans s i n=
	if n<=0 then nil
	else let skipname s i -> j in
	let strgetword s j -> typ in
	if typ==1 then
		strcatlist (itoa strget s j+10)::"."::(itoa strget s j+11)::"."::
		(itoa strget s j+12)::"."::(itoa strget s j+13)::nil
	else parseans s (j+10+strgetword s j+8) n-1;;
	
fun parsemsg s=
	let strgetword s 0 -> id in
	let strgetword s 2 -> code in
	let strgetword s 4 -> nbqu in
	let strgetword s 6 -> nbans in
	if nbans==0 then nil
	else let parsequs s 12 nbqu -> i in
	parseans s i nbans;;

fun filterdns src=
	let strfind src 0 "." 0 nil ->i in
	if i!=nil then
		strcat
			strcat ctoa i strsub src 0 i
			filterdns strsub src i+1 nil
	else strcat ctoa strlen src src;;

fun question id dns=
	strcatlist (itobin2 id)::"\$01\$00\$00\$01\$00\$00\$00\$00\$00\$00"::(filterdns dns)::"\$00\$00\$01\$00\$01"::nil;;

var dnsid=0;;

type Dns=[idD domainD reqD timeoutD cbD];;
var ldnsreq;;
var ldns;;

fun dnsreq domain cb=
	set dnsid=if dnsid==nil then time_ms else dnsid+1;
	let listswitchstr ldns domain -> ip in
	if ip!=nil then call cb[ip]
	else let dump question dnsid domain -> tramedns in
	(
		udpsend netip DNSLOCAL netdns 53 tramedns nil;
		set ldnsreq=[idD:dnsid domainD:domain reqD:tramedns timeoutD:time+5 cbD:cb]::ldnsreq;
		nil
	);
	0;;

fun selectbyid d v= d.idD==v;;

fun cbnetdns msg mac ipfrom= 
	let strgetword msg 0 -> id in
	let parsemsg msg -> ip in
	let hd select ldnsreq id #selectbyid -> x in
	if x!=nil then
	(
		set ldnsreq=listrem ldnsreq x;
		if ip!=nil then set ldns=[x.domainD ip]::ldns;	// ### attention � la taille de la liste
		call x.cbD [ip]
	);
	0;;

fun filterdnsdead l=if l!=nil then let hd l-> d in if d.timeoutD==nil then filterdnsdead tl l else (hd l)::filterdnsdead tl l;;

fun dnstime=
	for l=ldnsreq;l!=nil;tl l do let hd l-> d in
	if time-d.timeoutD>=0 then
	(
		set d.timeoutD=nil;
		call d.cbD [nil]
	);
	set ldnsreq=filterdnsdead ldnsreq;
	0;;


fun startdnsclient=
	regudp DNSLOCAL #cbnetdns;
	set ldnsreq=nil;
	set ldns=nil;
	0;;

// --------------- DNS fin

//------------ END ./lib/net/dns.mtl ------------



//------------ BEGIN ./lib/std/wifi.mtl ------------
var wifitry;;

fun _scanserialize l=
	if l!=nil then
	let hd l->[ssid mac bssid rssi channel rateset encryption] in
	ssid::"\0"::mac::bssid::(itoh4 rssi)::(itoh4 channel)::(itoh4 rateset)::(itoh4 encryption)::
	_scanserialize tl l;;

fun scanserialize l=
	(itoh4 listlen l)::_scanserialize l;;


fun ssidlen s i=
	if i>=strlen s then i
	else if !strget s i then i
	else ssidlen s i+1;;

fun scanunserialize s n i0=
	if n>0 then
	let ssidlen s i0 -> j in
	let j+1->i in
	[
		strsub s i0 j-i0
		strsub s i 6
		strsub s i+6 6
		htoi strsub s i+12 8
		htoi strsub s i+20 8
		htoi strsub s i+28 8
		htoi strsub s i+36 8
	]::scanunserialize s n-1 i+44;;


fun envmake =
	strcatlist netip::netmask::netgateway::netdns::scanserialize wifiscans;;

fun envrestore s =
	if s!=nil then
	(
		set netip=strsub s 0 4;
		set netmask=strsub s 4 4;
		set netgateway=strsub s 8 4;
		set netdns=strsub s 12 4;
		let htoi strsub s 16 8 -> nscan in
		set wifiscans=scanunserialize s nscan 24;
		0
	);;

fun scancmpssid a b=
	let a->[sa _ _ _ _ _ _] in
	let b->[sb _ _ _ _ _ _] in
	strcmp sa sb;;


fun wifiInit rescan=
	set wifitry=nil;
	let envget -> env in
	if env==nil then
	(
		//setleds 0xff00ff;
		set wifi=initW;
		if rescan then set wifiscans=nil;
		if master then
		(
			set netip=netip_master;
			set netmask=netmask_master;
			set netgateway=netgateway_master;
			0
		)
		else
		(
			if confGetDhcp then	set netip=netip_empty
			else
			(
				set netmask=confGetNetmask;
				set netgateway=confGetNetgateway;
				set netdns=confGetNetdns;
				set netip=confGetNetip
			);
			0
		);
		0
	)
	else
	(
		//setleds 0x00ff00;
		set mymac=netMac;
		set wifi=stationW;
		envrestore env;
		envset nil;
		nil
	);
	0;;

var laststate;;

fun wifibyssid x v=let x->[s _ _ _ _ _ _] in (s!=nil)&& !strcmp v s;;


var retrytime;;

fun _wifiwepkey val i len=
	if i<len then
	(htoi strsub val i 2)::_wifiwepkey val i+2 len;;

fun wifiwepkey val=
	let strlen val -> len in
	if len==5 || len==13 then val
	else let strreplace val ":" "" -> val in
	let if len<10 then 0 else if len<26 then 5 else 13 -> len in
	listtostr _wifiwepkey val 0 len<<1;;

fun wificrypttype crypt key=
	if crypt==1 then if 5==strlen key then IEEE80211_CRYPT_WEP64 else IEEE80211_CRYPT_WEP128
	else if crypt==2 then IEEE80211_CRYPT_WPA
	else IEEE80211_CRYPT_NONE;;

fun wifiAuth=
	//setleds 0xff8000;
	if wifiscans==nil then 0
	else
		let Iecholn confGetWificrypt -> crypt in
		let confGetWifiauth -> auth in
		let if crypt==1 then wifiwepkey confGetWifikey0
			else if crypt==2 then confGetWifipmk -> key in
		(
			dump key;
			set wifitry=time;
			netAuth hd wifiscans Iecholn auth (Iecholn wificrypttype crypt key) key;	//## ajouter les param�tres de crypto
			1
		);;

fun wifiRun=
	let netState -> state in
	(
		if state!=laststate then (Secho "wifi state=";Iecholn state);
		let match wifi with
		(stationW -> nil)
		|(initW -> if state==RT2501_S_IDLE then
				(
					set mymac=MACecho netMac 0 1;
					//setleds 0xff8000;
					if master then
					(
						dumpscan set wifiscans=sort netScan nil #scancmpssid;
						netSetmode IEEE80211_M_MASTER (strcat "Nabaztag" ctoh strget mymac 5) 1;
						Secholn "-------------gomaster";
						gomasterW
					)
					else
					(
						if wifiscans==nil then
						(
							let confGetWifissid -> ssid in
							let if strlen ssid then ssid else nil -> ssid in
							let netScan ssid -> lscan in
							let sort lscan #scancmpssid -> l in
							let if ssid==nil then l else select l ssid #wifibyssid-> l in
							dumpscan set wifiscans=l
						);
						if wifiAuth then
						(
							Secho confGetWifissid; Secholn ":-------------gostation";
							gostationW [0 time]
						)
					)
				)
			)
		|(gomasterW -> if state==RT2501_S_MASTER then
				(
					//setleds 0x0000ff;
					Secholn "-------------master";
					startdhcpserver;
//					startconfigserver 80;
					masterW)
			)
		|(masterW -> if !master then
					(
						wifiInit 1;
						resetudp;
						netSetmode IEEE80211_M_MANAGED nil 11;
						nil)
			)
		|(gostationW x-> if state==RT2501_S_CONNECTED then
				(
					Secholn "-------------dhcp";
					if confGetDhcp then startdhcp;
					startdnsclient;
					dhcpW time
				)
			)
		|(dhcpW t-> if netip!=netip_empty then
				(
					Secholn "-------------station";
					stationW
				)
				else if (time-t)>3 then	// retry dhcp client
				(
					startdhcp;
					dhcpW time
				)
			)
		|(reconnectW ->
			netSetmode IEEE80211_M_MANAGED nil 11;
			if wifiAuth then
			(
				Secho confGetWifissid; Secholn ":-------------gostation";
				gostationW [0 time]
			)
		 )
		-> nwifi in
		if nwifi!=nil then set wifi=nwifi;
		set laststate=state
	);
	if retrytime!=time then
	(
		set retrytime=time;
		nettime;
		dnstime;
		0
	)
	;;

fun wifiReady= match wifi with (stationW -> 1)|(_ -> 0);;

fun wifiConnected= match wifi with (stationW -> 1)|(_ -> 0);;


//------------ END ./lib/std/wifi.mtl ------------


//------------ BEGIN ./lib/net/http.mtl ------------
//------------------- HTTP
var HTTP_NORMAL=0;;
var HTTP_STREAM=1;;
var HTTP_DIRECT=2;;

var HTTP_SOLVE=0;;
var HTTP_REACH=1;;
var HTTP_CONNECTED=2;;

var lasthttpevent;;

// type Httpreq contenant l'�tat d'une requ�te
type Httpreq=[cnxH inputH outputH indexH cbH typeH stateH aliveH];;

// callback de lecture sur la socket d'une requ�te
fun tcpread cnx input httpreq=
	if input==nil ||0==strlen input then	// erreur ou fin
	(	closetcp cnx;	// on ferme la socket
		if httpreq.typeH==HTTP_NORMAL then call httpreq.cbH [httpreq strcatlist rev httpreq.inputH nil]	// on retourne ce qui a �t� re�u
		else call httpreq.cbH [httpreq nil]
	)
	else
	(
//		dump input;
		set lasthttpevent=time;
		set httpreq.aliveH=time_ms;
		if httpreq.typeH==HTTP_NORMAL then set httpreq.inputH=input::httpreq.inputH	// on bufferise ce qui a �t� re�u
		else if httpreq.typeH==HTTP_DIRECT then
		(
			call httpreq.cbH [httpreq input];
			nil
		)
		else let strcat hd httpreq.inputH input -> s in
		let strstr s "\13\10\13\10" 0 -> i in
		if i==nil then
		(
			set httpreq.inputH=s::nil
		)
		else
		(
			set httpreq.inputH=nil;
			set httpreq.typeH=HTTP_DIRECT;
			call httpreq.cbH [httpreq strsub s 0 i];
			if i+4<strlen s then call httpreq.cbH [httpreq strsub s i+4 nil];
			nil
		);
		nil
	);;

// callback d'�criture sur la socket d'une requ�te
fun tcpwrite cnx httpreq=
	set httpreq.stateH=HTTP_CONNECTED; 
	set httpreq.aliveH=time_ms;	
	if httpreq.outputH!=nil then	// s'il y a des choses � envoyer (notamment la premi�re fois)
	(
		set httpreq.indexH=writetcp cnx httpreq.outputH httpreq.indexH;	// envoyer ce qui peut l'�tre
		if httpreq.indexH==nil then	// si erreur lors de l'envoi
		(	closetcp cnx;	// on ferme la socket
			call httpreq.cbH [httpreq nil]	)	// on retourne nil
		else if httpreq.indexH>=strlen httpreq.outputH then	// sinon si tout a �t� envoy�
		(	set httpreq.indexH=nil;	// purger les donn�es d'�mission
			set httpreq.outputH=nil;
			nil
		)
	);;

var http_prefurl="http://";;	// en-t�te normal (mais ici facultatif) d'une requ�te http

fun isip s i=
	if i>=strlen s then 1
	else let strget s i -> c in
	if (c<'0' || c>'9')&&c!='.' then 0
	else isip s i+1;;


// d�couper une url en [host port path].
// host est de la forme ip:port
// path ne commence pas par /
fun cuturl url =
	if !strcmp (strsub url 0 strlen http_prefurl) http_prefurl then cuturl strsub url strlen http_prefurl strlen url
	else let strstr url "/" 0 -> i in
		let if i==nil then url else strsub url 0 i -> addr in
		let strstr addr ":" 0 -> j in
		let if j==nil then [addr 80]
			else [strsub addr 0 j atoi strsub addr j+1 strlen addr] -> [host port] in
		let if i==nil then "/" else strsub url i strlen url -> path in
		[host port path];;

fun tcpevent t val msg sock=
	if val==TCPWRITE then tcpwrite t sock
	else if val==TCPCLOSE then tcpread t nil sock
	else tcpread t msg sock;
	0;;


fun httpsendreq ip x=
	Secho "found ip>>>>>>>>>>>>>>>>>>>>>>>>>"; Secholn ip;
	let x->[port httpreq] in
	if ip==nil then (call httpreq.cbH [httpreq nil]; nil)
	else
	(
		set httpreq.cnxH=opentcp netip nil useparamip ip port fixarg4 #tcpevent httpreq;
		set httpreq.stateH=HTTP_REACH;
		nil
	);
	0;;


//##> cr�ation d'une requ�te http
// param�tres : verb=verbe de la requ�te url=url de la requ�te postdata=donn�es suppl�mentaires (nil si aucune) cb=callback de retour
fun httprequest verb url postdata cb type=
//	Secho "HTTPREQUEST url =";Secholn url;
	let cuturl url ->[host port path] in	// d�codage de l'url de la requ�te
	let if confGetProxy then strcatlist "http://"::host::":"::(itoa port)::path::nil else path -> path in //Icy-MetaData:1\13\n
	let strcatlist verb::" "::path::" HTTP/1.0\13\nUser-Agent: MTL\13\nPragma: no-cache\13\nIcy-MetaData:1\13\nHost: "::host::"\13\n"::
			if postdata==nil then "\13\n"::nil
			else "Content-length: "::(itoa strlen postdata)::"\13\n\13\n"::postdata::nil
		-> request in	// cr�ation de la cha�ne requ�te
	let if confGetProxy then webip confGetProxyip else host -> host in
	let if confGetProxy then confGetProxyport else port -> port in
	let [outputH:request indexH:0 cbH:cb typeH:type stateH:HTTP_SOLVE aliveH:time_ms] -> httpreq in	// cr�ation de la structure requ�te
	(
//		Secho "HTTPREQUEST host =";Secholn host;
		if isip host 0 then httpsendreq host [port httpreq]
		else
		(
			dnsreq host fixarg2 #httpsendreq [port httpreq];
			nil
		);
		httpreq	// on retourne la structure requ�te pour pouvoir �ventuellement l'interrompre en cours de route
	);;

//##> interruption d'une requ�te en cours
fun httpabort httpreq=
	closetcp httpreq.cnxH;;	// on ferme la socket de la requ�te

fun httpenable httpreq v=
	enabletcp httpreq.cnxH v;;

fun httpstate httpreq = httpreq.stateH;;

fun httpinactive httpreq = time_ms-httpreq.aliveH;;


var http_sep="\13\n\13\n";;	// s�parateur entre l'en-t�te et le corps de la r�ponse � une requ�te

	

//##> retourne le header d'une r�ponse � une requ�te
fun httpgetheader res =
	let strstr res http_sep 0 -> i in
	if i==nil then res
	else strsub res 0 i+strlen http_sep;;

//##> retourne le contenu d'une r�ponse � une requ�te (sans header)
fun httpgetcontent res =
	let strstr res http_sep 0 -> i in
	if i==nil then nil
	else strsub res i+strlen http_sep strlen res;;

//-------------------

//------------ END ./lib/net/http.mtl ------------


//------------ BEGIN ./lib/std/audiolib.mtl ------------
ifdef AUDIOLIB {

var WAV_IDLE=0;;
var WAV_RUN=1;;
var WAV_EOF=2;;

var WAV_BUFFER_STARTSIZE=80000;;
var WAV_BUFFER_MAXSIZE=400000;;

var WAV_END_TIMEOUT=500;;
var WAV_NET_TIMEOUT=10000;;

var wav_end_timeout;;

var wav_state=0;;
var wav_http;;
var wav_fifo;;
var wav_buffering;;
var wav_index;;
var wav_lasttime;;
var wav_lastnet;;
var wav_zeros;;

var lastvol;;
var forcedvol=0;;
fun volfrombutton v=let 255-v -> v in 255-((v*v)>>8);;

/*
fun updatevol=
	let button3 -> v in
	if !forcedvol && v!=lastvol && (!recording) && (lastvol!=255 || v<250) then
	(
		set lastvol=v;
		sndVol volfrombutton v
	);;
*/

fun forcevol v=
	sndVol volfrombutton (button3*v)>>8;
	set forcedvol=1;
	0;;
fun unforcevol=
	set forcedvol=0;
	set lastvol=nil;
	0;;

fun wavgetzeros=
	if wav_zeros==nil then
	(
		set wav_zeros=strnew 2048;
		for i=0;i<2048 do strset wav_zeros i 0
	);
	wav_zeros;;

fun wavstop =
Secholn "###wavstop";
	if wav_state!=WAV_IDLE then
	(
		playStop;
		if wav_http!=nil then httpabort wav_http;
		set wav_http=nil;
		set wav_state=WAV_IDLE
	);;

fun wavrunning =
	if wav_state==WAV_IDLE then 0
	else if wav_fifo==nil && wav_state==WAV_EOF && (time_ms-wav_lasttime>wav_end_timeout) then
	(
Secholn "###wav detected end";
		wavstop;
		0
	)
	else if wav_lasttime==nil then -1 else 1;;

fun _wavcb i =
//Secho "p";
	set wav_lasttime=time_ms;
//	Iecho i;Secho ":cbplay\n";
	if wav_fifo==nil then
	(
		if wav_state==WAV_EOF then playFeed nil nil nil
		else
		(
				if !wav_buffering then Secholn ">>>>buffering...............";
				set wav_buffering=1
		)
	)
	else
	(
		if wav_buffering && (wav_state==WAV_EOF || (slistlen wav_fifo)>=WAV_BUFFER_STARTSIZE)
			then set wav_buffering=0;
		if !wav_buffering then let hd wav_fifo -> sample in
		let strlen sample -> len in
		(
			if wav_index<len then 
				set wav_index=wav_index+playFeed sample /*Iecho*/ wav_index nil;
			if wav_index>=len then
			(
				set wav_index=0;
				set wav_fifo=tl wav_fifo;
				if wav_http!=nil then if (slistlen wav_fifo)<WAV_BUFFER_MAXSIZE then httpenable wav_http 1
			)
		)
	);
	0;;

fun _wavstartnow =
	set wav_index=0;
	set wav_buffering=1;
	playStart 1024 #_wavcb;;

fun wavstartlocalEx l timeout=
	wavstop;
	set wav_end_timeout=timeout;
	set wav_fifo=conc l (wavgetzeros)::nil;
	set wav_state=WAV_EOF;
	set wav_lasttime=time_ms;
	set wav_http=nil;
	_wavstartnow
	;;

fun wavstartlocal l=wavstartlocalEx l WAV_END_TIMEOUT;;
/*
fun itobin4 i=strcatlist (ctoa i)::(ctoa i>>8)::(ctoa i>>16)::(ctoa i>>24)::nil;;
fun itobin2 i=strcatlist (ctoa i)::(ctoa i>>8)::nil;;

fun mkwav freq channel bps=
	let strcatlist 
		"WAVEfmt "::(itobin4 0x12)::
			(itobin2 1)::(itobin2 channel)::
			(itobin4 freq)::(itobin4 freq*channel*bps/8)::
			(itobin2 channel*bps/8)::(itobin4 bps)::
		"data"::(itobin4 0)::nil -> c in
	strcatlist "RIFF"::(itobin4 (strlen c))::c::nil;;
*/

fun _wavcbhttp httpreq req=
	set wav_lastnet=time_ms;
	if req==nil then
	(
		Secholn ">>>>>>>>>>>>>>>>>>>>>>>>>>>>><end of file";
		set wav_state=WAV_EOF;
		if wav_fifo!=nil then set wav_fifo=conc wav_fifo (wavgetzeros)::nil;
		if wav_index==nil then
		(
			set wav_fifo=tl wav_fifo;
			if wav_fifo==nil then wavstop
			else _wavstartnow
		);
		0
	)
	else
	(
//		dump req;
		set wav_fifo=conc wav_fifo req::nil;
		let slistlen wav_fifo -> n in
		if wav_index==nil && n>WAV_BUFFER_STARTSIZE then
		(
			set wav_fifo=tl wav_fifo;
			_wavstartnow
		)
		else if n>WAV_BUFFER_MAXSIZE then
		(
			Secholn "\n>>>>>>>>>>>>>>http wait";
			httpenable httpreq 0
		);
		nil
	);
	//updatevol;
	0;;

fun wavstarthttp url =
	wavstop;
	set wav_end_timeout=WAV_END_TIMEOUT;
	set wav_fifo=nil;
	set wav_state=WAV_RUN;
	set wav_index=nil;
	set wav_buffering=1;
	set wav_lasttime=nil;
	set wav_lastnet=time_ms;
	set wav_http=httprequest "GET" url nil #_wavcbhttp HTTP_STREAM;;

fun wavtime =
	if wav_http!=nil && wav_state==WAV_RUN && (time_ms-wav_lastnet>WAV_NET_TIMEOUT) then
	(
		if wav_http!=nil then
		(
			Secholn "####wavhttp abort";
			httpabort wav_http;
			set wav_http=nil;
			_wavcbhttp wav_http nil;
			0
		)
	);
//	wavrunning;
	0;;

}
//------------ END ./lib/std/audiolib.mtl ------------



//------------ BEGIN ./utils.mtl ------------
fun dumpList l0=
  for l=l0;l!=nil;tl l do (Secho hd l; Secho "::");
  Secholn "nil";;

fun split data separator lst =
  let strlen data -> len in
  let strstr data separator 0 -> idx in
  let strsub data 0 idx -> a in
  let strsub data idx+1 len-idx-1 -> b in
    if idx == nil then data::lst
    else split b separator a::lst;;

var conn;;

fun _writetcpconn data index retries = 
  if index >= strlen data then (
    Secholn "end ok";
    index
  )
  else if retries > 100 then (
    Secholn "end fail";
    nil
  )
  else (
    let writetcp conn data index -> ret in (
      Iecholn ret;
      if ret == nil || ret == 0 then
        _writetcpconn data index retries+1
      else
        _writetcpconn data ret 0
    )
  )
  ;;

fun writetcpconn data = _writetcpconn data 0 0;;


fun _strtohex key i=
  if i < strlen key then (ctoh strget key i)::_strtohex key i+1;;

fun strtohex key=
  strcatlist _strtohex key 0;;
/*
fun _hextostr data i=
  if i < strlen data then (itoa (htoi (strsub data i 2)))::_hextostr data i+2;;

fun hextostr data=
  strcatlist _hextostr data 0;;
*/
//------------ END ./utils.mtl ------------


//------------ BEGIN ./led.mtl ------------

const RGB_BLACK = 0x000000;;
type Led=[next_change index size colors intervals];;
var leds;;

fun ledInit = 
    set leds = tabnew nil 5;
    for i = 0; i < 5 do (
        set leds.i = [next_change: -1 index: 0 size: 1 colors: {RGB_BLACK} intervals: {0}];
        led i RGB_BLACK
    );;

fun ledHandler data t =
    let rev split data ";" nil nil -> c1 in
    let atoi hd c1 -> led_id in
    let tl c1 -> c2 in
    let atoi hd c2 -> start_after in
    let tl c2 -> c3 in
    let (listlen c3) / 2 -> size in
    let tabnew nil size -> colors in
    let tabnew nil size -> intervals in
    let 0 -> cpt in (
        for l=c3; l!=nil; tl tl l do (
            set colors.cpt = htoi hd l;
            set intervals.cpt = atoi hd tl l;
            set cpt = cpt+1
        );
        set leds.led_id = [next_change: t+start_after index: 0 size: size colors: colors intervals: intervals]
    );
    /*let leds.1 -> l in (
        Iecholn l.size;
        Iecholn l.index;
        for i = 0; i<l.size do Iecholn l.colors.i
    );*/
    0;;

fun ledLoop =
    for i = 0; i < 5 do (
        let leds.i -> l in (
            if l.next_change != -1 && time_ms >= l.next_change then (
                let l.index -> j in (
                    led i l.colors.j;
                    if l.intervals.j == 0 then 
                        set leds.i = [next_change: -1 index: 0 size: l.size colors: l.colors intervals: l.intervals]
                    else
                        set leds.i = [next_change: time_ms+l.intervals.j index: (j+1)%l.size size: l.size colors: l.colors intervals: l.intervals]
                )
            )
        ) 
    );;

//------------ END ./led.mtl ------------


//------------ BEGIN ./ear.mtl ------------

/*
    lastTime: last move request time
    targetPos: position to move to
    isMoving: if the ear is supposed to be moving
    isBroken: if the ear is broken
    
    lastPos: last position 
    lastPosTime: last time position changed
*/
type EarState=[lastTime targetPos isMoving isBroken lastPos lastPosTime reported];;
type Ear=[next_change index size positions directions intervals];;
var earState;;
var ears;;

fun earDump l = 
        Iecholn l.next_change;
        Iecholn l.size;
        Iecholn l.index;
        Secholn "pos";
        for i = 0; i<l.size do Iecholn l.positions.i;
        Secholn "dir";
        for i = 0; i<l.size do Iecholn l.directions.i;
        Secholn "int";
        for i = 0; i<l.size do Iecholn l.intervals.i
    ;;

fun earStateDump l = 
    Secholn strcatlist "lastTime:"::(itoa l.lastTime)::" targetPos:"::(itoa l.targetPos)::" isMoving:"::(itoa l.isMoving)::" isBroken:"::(itoa l.isBroken)::" lastPos:"::(itoa l.lastPos)::" lastPosTime:"::(itoa l.lastPosTime)::" reported:"::(itoa l.reported)::nil;;

fun earInit = 
    set ears = tabnew nil 2;
    set earState = tabnew nil 2;
    for i = 0; i < 2 do (
        set earState.i = [lastTime: 0 targetPos: 0 isMoving: 0 isBroken: 0 lastPos: 0 lastPosTime: 0 reported: 1];
        set ears.i = [next_change: -1 index: 0 size: 1 positions: {0} directions: {0} intervals: {0}]
    );
    earStateDump earState.0
    ;;

fun earHandler data t =
    //Secholn "ear";
    let rev split data ";" nil nil -> c1 in
    let atoi hd c1 -> ear_id in
    let tl c1 -> c2 in
    let atoi hd c2 -> start_after in
    let tl c2 -> c3 in
    let (listlen c3) / 3 -> size in
    let tabnew nil size -> positions in
    let tabnew nil size -> directions in
    let tabnew nil size -> intervals in
    let 0 -> cpt in (
        for l=c3; l!=nil; tl tl tl l do (
            set positions.cpt = atoi hd l;
            set directions.cpt = atoi hd tl l;
            set intervals.cpt = atoi hd tl tl l;
            set cpt = cpt+1
        );
        set ears.ear_id = [next_change: t+start_after index: 0 size: size positions: positions directions: directions intervals: intervals]
    );
    earDump ears.1;
    0;;

fun earLoop =
    for i = 0; i < 2 do (
        //Secholn strcatlist "ear"::(itoa i)::nil;

        let earState.i -> es in
        if es.isBroken != 1 then
            let (motorget i)%17 -> state in
                if es.isMoving == 1 then (
                    // if moving
                    Secholn "moving";
                    if state == es.targetPos then (
                        Secholn "stopped ok";
                        // if reached requested state, stop motor
                        set earState.i = [lastTime: es.lastTime targetPos: es.targetPos isMoving: 0 isBroken: es.isBroken lastPos: state lastPosTime: time_ms reported: 1];
                        motorset i 0
                    ) else if time_ms >= es.lastTime + 8000 then (
                        Secholn "stopped fail";
                        // if moving for more than 5s (and target state not reached), mark ear as broken
                        //set earState.i = [lastTime: time_ms targetPos: 0 isMoving: 0 isBroken: 1 lastPos: 0 lastPosTime: 0 reported: 1];
                        set earState.i = [lastTime: es.lastTime targetPos: es.targetPos isMoving: 0 isBroken: es.isBroken lastPos: state lastPosTime: time_ms reported: 1];
                        motorset i 0
                    )
                )
                else (
                    if state != es.lastPos then (
                        // if state changed, update lastPos/lastPosTime
                        Secholn "state changed";
                        Iecholn state;
                        //earStateDump es;
                        set earState.i = [lastTime: es.lastTime targetPos: es.targetPos isMoving: es.isMoving isBroken: es.isBroken lastPos: state lastPosTime: time_ms reported: 0]
                        ;0
                    )
                    else (
                        if es.reported == 0 && es.lastPosTime + 500 < time_ms then (
                            Secholn "reporting change";
                            // if last state have changed but is stable for 500ms, send update to server
                            writetcpconn strcatlist "11;"::(itoa i)::";"::(itoa es.lastPos)::nil;
                            set earState.i = [lastTime: es.lastTime targetPos: es.targetPos isMoving: es.isMoving isBroken: es.isBroken lastPos: es.lastPos lastPosTime: es.lastPosTime reported: 1]
                        );
                        
                        // follow defined patterns (similar to led)
                        let ears.i -> e in (
                            if e.next_change != -1 && time_ms >= e.next_change then (
                                //Secholn "executing step";
                                let e.index -> j in (
                                    // start moving to e.positions.j with e.directions.j 
                                    set earState.i =  [lastTime: time_ms targetPos: e.positions.j isMoving: 1 isBroken: es.isBroken lastPos: es.lastPos lastPosTime: es.lastPosTime reported: es.reported];
                                    motorset i if e.directions.j == 1 then 1 else -1;
                                    Secholn "started";

                                    // update next step
                                    if e.intervals.j == 0 then 
                                        set ears.i = [next_change: -1 index: 0 size: e.size positions: e.positions directions: e.directions intervals: e.intervals]
                                    else
                                        set ears.i = [next_change: time_ms+e.intervals.j index: (j+1)%e.size size: e.size positions: e.positions directions: e.directions intervals: e.intervals]
                                )
                            )
                        );0
                    )
                )
    );;

//------------ END ./ear.mtl ------------


//------------ BEGIN ./events.mtl ------------
type Button=[last_time last_state reported nbclick];;
var btn;;
var wheel;;
var lastRfid;;

fun eventsInit = 
    set lastRfid = 0;
    set btn = [last_time: 0 last_state: 0 reported: 1 nbclick: 0];
    set wheel = [last_time: 0 last_state: -1 reported: 1 nbclick: 0]
    ;;

fun buttonLoop = 
    let button3 -> w in
        if w != wheel.last_state then (
            set wheel = [last_time: time_ms last_state: w reported: 0 nbclick: 0];0
        )
        else if wheel.reported == 0 && wheel.last_time + 500 < time_ms then (
            set wheel = [last_time: wheel.last_time last_state: wheel.last_state reported: 1 nbclick: 0];
            writetcpconn strcatlist "10;"::(itoa wheel.last_state)::nil
        );
    
    let button2 -> b in (
        if b != btn.last_state then (
            if b == 0 then 
                set btn = [last_time: time_ms last_state: b reported: 0 nbclick: btn.nbclick]
            else
                set btn = [last_time: time_ms last_state: b reported: 0 nbclick: btn.nbclick+1]
        ) else if btn.reported == 0 && btn.last_time + 500 < time_ms then (
            if btn.last_state == 1 && btn.last_time + 600 < time_ms then (
                writetcpconn "04;3"; // long click
                set btn = [last_time: time_ms last_state: 1 reported: 1 nbclick: 0]
            )
            else if btn.nbclick > 1 then (
                writetcpconn "04;2"; // double click
                set btn = [last_time: time_ms last_state: 0 reported: 1 nbclick: 0]
            )
            else if btn.last_state == 0 then (
                writetcpconn "04;1"; // simple click
                set btn = [last_time: time_ms last_state: 0 reported: 1 nbclick: 0]
            )
        )
    )
    ;;

fun rfidLoop =
    if lastRfid + 100 < time_ms then (
        set lastRfid = time_ms;
        let rfidGet -> x in
        if x != nil && x != "ERROR" then (
            writetcpconn strcatlist "05;"::(strtohex x)::nil
        )
    );;
//------------ END ./events.mtl ------------


//------------ BEGIN ./recorder.mtl ------------

var isRecording;;

// conn.dstT is the address of the client connected to our tcp server
// netip is the address of the rabbit
fun writerecdata data = 
    let strlen data -> len in
    if len > 512 then (
        udpsend netip 4000 conn.dstT 4000 strcatlist "snd"::(strsub data 0 512)::nil nil;
        writerecdata strsub data 512 nil
    ) else (
        udpsend netip 4000 conn.dstT 4000 strcatlist "snd"::data::nil nil
    );;

fun cbrec s = 
    writerecdata s;
    0;;

fun recorderHandler data = 
    let rev split data ";" nil nil -> x in
    let atoi hd x -> tp in
        if tp == 0 && isRecording > 0 then (
            // stop
            set isRecording = 0;
            recStop
        ) else if tp == 1 && isRecording <= 0 then (
            // start
            set isRecording = 1;
            recStart 8000 0 #cbrec
        );;

//------------ END ./recorder.mtl ------------


//------------ BEGIN ./player.mtl ------------
var isPlaying;;
var audio_fifo;;
var wav_index = 0;;

fun wavcb i =
	let hd audio_fifo -> sample in
    let strlen sample -> len in
    (
        if wav_index<len then 
            set wav_index=wav_index+playFeed sample wav_index nil;
        if wav_index>=len then
        (
            set wav_index=0;
            set audio_fifo=tl audio_fifo
        )
    );
	0;;

fun playerUDPHandler data =
    led 1 0x00FF00;
    Secholn data;
    set audio_fifo=conc audio_fifo data::nil;;

fun playerHandler data = 
    let rev split data ";" nil nil -> x in
    let atoi hd x -> tp in
        if tp == 0 && isPlaying > 0 then (
            // stop
            led 0 0xFF0000;
            Secholn "player stopped";
            set isPlaying = 0;
            playStop
        ) else if tp == 1 && isPlaying <= 0 then (
            // start
            led 0 0x00FF00;
            Secholn "player started";
            set isPlaying = 1;
            playStart 1024 #wavcb
        ) else if tp == 2 then (
            led 0 0x0000FF;
            sndVol atoi hd tl x
        )
        ;;

fun midiHandler data = 
    Secholn data;;

//------------ END ./player.mtl ------------


//------------ BEGIN ./server.mtl ------------

//--------------------------------------------------------------------------------------------------
// TCP Socket Server
//--------------------------------------------------------------------------------------------------

fun tcpread cnx input=
  for l=split input "\n" nil; l!=nil; tl l do (
    let hd l -> msg in
    let time_ms -> t in
    let strsub msg 0 2 -> pktType in
        if !strcmp pktType "00" then 
        (
          writetcpconn "00;pong;";
          0
        )
        else if !strcmp pktType "01" then
        (
          reboot 0x0407FE58 0x13fb6754;
          0
        )
        else if !strcmp pktType "02" then
        (
          earHandler strsub msg 3 nil t;
          0
        )
        else if !strcmp pktType "03" then
        (
          ledHandler strsub msg 3 nil t;
          0
        )
        else if !strcmp pktType "06" then
        (
          recorderHandler strsub msg 3 nil;
          0
        )
        else if !strcmp pktType "07" then
        (
          playerHandler strsub msg 3 nil;
          0
        )
        else if !strcmp pktType "09" then
        (
          midiHandler strsub msg 3 nil;
          0
        )
        else
        (
          Secholn pktType;
          Secholn "unknown packet";
          0
        )
  );
  nil
  ;;

fun tcpevent cnx val msg=
    if val==TCPSTART || val==TCPREAD then (
      // when not using the simulator, TCPSTART are not received
      //set conn = cnx::conn;
      set conn = cnx;
      tcpread cnx msg
    )
    else if val==TCPCLOSE then (
        //set conn = remfromlist conn cnx;
        set conn = nil;
        // when using the simulator, when reconnecting after a socket is closed
        // the system closes the connection, this is not an issue on real hardware
        closetcp cnx
    );
    0;;

fun cbsrv cnx code msg=
    tcpcb cnx #tcpevent;
    0;;

fun cbudpsrv msg mac ipfrom= 
  Secholn msg;
  let strsub msg 0 3 -> pktType in (
    if !strcmp pktType "snd" then
      playerUDPHandler strsub msg 3 nil
  );
	0;;

fun startserver tcpport udpport=
    regudp udpport #cbudpsrv;
    listentcp tcpport #cbsrv;
    Secholn "start server";
    0;;

//------------ END ./server.mtl ------------

fun mainSetup = 
    ledInit;
    earInit;
    eventsInit;
    Secholn "test";;

fun mainLoop = 
    //ledLoop;
    earLoop;
    buttonLoop;
    rfidLoop;
    //Secholn "loop";
    0;;

fun main=
    Secholn "starting";
    confInit;
    wifiInit 0;
    netstart;
    startdnsclient;
    mainSetup;
    startserver 5000 4000;
    loopcb #mainLoop;
    Secholn "hello world ------------";
    0;;

//------------ END ./main.mtl ------------
